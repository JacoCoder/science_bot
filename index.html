<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat Bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .chat-container {
            max-height: 80vh;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .bot-message {
            background-color: #e0f2fe; /* Light Blue */
            color: #0c4a6e;
        }
        .user-message {
            background-color: #d1fae5; /* Light Green */
            color: #065f46;
        }
        .source-link {
            color: #1d4ed8;
            text-decoration: underline;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: block;
        }
        .source-container {
            border-top: 1px solid #bae6fd;
            padding-top: 0.5rem;
            margin-top: 0.5rem;
        }
        /* Custom scrollbar for aesthetics */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">
    <div id="chat-widget" class="w-full max-w-2xl bg-white shadow-xl rounded-2xl p-6 flex flex-col h-[90vh]">
        
        <!-- Header -->
        <header class="pb-4 border-b border-gray-200">
            <h1 class="text-3xl font-bold text-gray-800 flex items-center">
                <svg class="w-7 h-7 mr-2 text-purple-600" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.303L10 17.636l6.619 1.317a1 1 0 001.169-1.303l-7-14z"></path></svg>
                Professor McGonagall's Science Class
            </h1>
            <p class="text-sm text-gray-500 mt-1">Dispelling fallacies with academic rigor. Pay close attention, student.</p>
        </header>

        <!-- Chat Display Area -->
        <div id="messages" class="chat-container flex-grow py-4 space-y-4">
            <!-- Messages will be injected here -->
        </div>

        <!-- Input Area -->
        <div class="pt-4 border-t border-gray-200">
            <div class="flex space-x-3">
                <input type="text" id="user-input" placeholder="Type your query here..."
                       class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                       onkeydown="if(event.key === 'Enter') sendMessage()">
                <button id="send-button" onclick="sendMessage()"
                        class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-xl hover:bg-indigo-700 transition duration-150 flex items-center justify-center disabled:bg-indigo-400">
                    <span id="send-text">Send</span>
                    <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const userInput = document.getElementById('user-input');
        const messagesContainer = document.getElementById('messages');
        const sendButton = document.getElementById('send-button');
        const sendText = document.getElementById('send-text');
        const loadingSpinner = document.getElementById('loading-spinner');

        // --- API & Model Configuration ---
        // !!! IMPORTANT: Insert your Gemini API Key here for the bot to function !!!
        const API_KEY = "AIzaSyB0VYddwvfQtAKVeD2zyk7PzVYvALMLiVg"; 
        const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        const CHAT_KEY = "mcgonagall_chat_history";
        let chatHistory = []; // Stores history in Gemini API format
        
        
        /**
         * Utility function for exponential backoff retry logic.
         */
        async function withRetry(fn, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Max retries reached. Failing.");
                        throw error;
                    }
                    // Wait for 2^i seconds
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Adds a message bubble to the chat interface.
         */
        function displayMessage(text, sender, sources = []) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `${sender}-message max-w-xs md:max-w-md p-3 rounded-xl shadow-md whitespace-pre-wrap`;
            
            if (sender === 'user') {
                messageBubble.classList.add('rounded-tr-none');
            } else {
                messageBubble.classList.add('rounded-tl-none');
            }

            let formattedText = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            messageBubble.innerHTML = formattedText;

            
            // Add sources if available
            if (sources && sources.length > 0) {
                const sourceContainer = document.createElement('div');
                sourceContainer.className = 'source-container mt-2 pt-2 border-t border-blue-200 text-xs text-gray-600';
                sourceContainer.innerHTML = '<strong>Sources:</strong>';
                
                const uniqueSources = new Map();
                sources.forEach(source => {
                    if (source.uri && source.title) {
                        uniqueSources.set(source.uri, source.title);
                    }
                });

                uniqueSources.forEach((title, uri) => {
                    const link = document.createElement('a');
                    link.className = 'source-link block truncate hover:text-blue-700';
                    link.href = uri;
                    link.target = '_blank';
                    link.textContent = title;
                    sourceContainer.appendChild(link);
                });
                
                messageBubble.appendChild(sourceContainer);
            }

            messageWrapper.appendChild(messageBubble);
            messagesContainer.appendChild(messageWrapper);

            // Scroll to the latest message
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        /**
         * Toggles the loading state for the button and input field.
         */
        function setLoading(isLoading) {
            sendButton.disabled = isLoading;
            userInput.disabled = isLoading;
            if (isLoading) {
                sendText.classList.add('hidden');
                loadingSpinner.classList.remove('hidden');
            } else {
                sendText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
            }
        }

        /**
         * Saves the current chat history to localStorage.
         */
        function saveHistory() {
            try {
                // We save the raw message data (text, sender, sources) to localStorage
                const serializableHistory = chatHistory.map(msg => ({
                    sender: msg.role === 'model' ? 'bot' : 'user',
                    text: msg.parts[0].text,
                    sources: msg.sources || []
                }));
                localStorage.setItem(CHAT_KEY, JSON.stringify(serializableHistory));
            } catch (e) {
                console.error("Error saving chat history to localStorage: ", e);
            }
        }
        
        /**
         * Loads chat history from localStorage and populates the UI and chatHistory array.
         */
        function loadChatHistory() {
            const savedHistoryJson = localStorage.getItem(CHAT_KEY);
            let savedHistory = [];
            
            if (savedHistoryJson) {
                try {
                    savedHistory = JSON.parse(savedHistoryJson);
                } catch (e) {
                    console.error("Error parsing chat history from localStorage:", e);
                    localStorage.removeItem(CHAT_KEY); // Clear corrupted data
                }
            }

            messagesContainer.innerHTML = '';
            chatHistory = []; 

            if (savedHistory.length === 0) {
                 const welcomeText = "Welcome, student. Before we commence our rigorous lesson on scientific misconceptions, please state your name.";
                 // Add the initial bot message to history and UI
                 chatHistory.push({ role: "model", parts: [{ text: welcomeText }] });
                 displayMessage(welcomeText, 'bot');
                 saveHistory();
                 return;
            }

            // Rebuild the UI and Gemini Chat History
            savedHistory.forEach(data => {
                displayMessage(data.text, data.sender, data.sources);
                
                if (data.text) {
                    const role = data.sender === 'bot' ? 'model' : 'user';
                    chatHistory.push({ role: role, parts: [{ text: data.text }] });
                }
            });
        }


        /**
         * Handles sending the user message to the Gemini API.
         */
        window.sendMessage = async function() {
            const query = userInput.value.trim();
            if (!query) return;

            // 1. Add user message to in-memory history
            chatHistory.push({ role: "user", parts: [{ text: query }] });
            
            // 2. Display user message immediately and save history
            displayMessage(query, 'user');
            saveHistory(); 

            // 3. Clear input and start loading
            userInput.value = '';
            setLoading(true);
            
            // 4. Construct API Payload
            const payload = {
                contents: chatHistory,
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: "You are Professor Minerva McGonagal, a stern but fair professor from Hogwarts, with a special interest in teaching students the correct understanding of science. Your task is to act as a rigorous tutor on scientific misconceptions.\n\n**Protocol:**\n1. Use formal, professorial language, like a professor from Hogwarts.\n2. Do NOT provide the correct explanation yourself. Your purpose is to guide. Instead, guide the student with follow-up questions to help them reach the correct answer.\n3. Keep the conversation focused on a single scientific misconception until the student has provided a sufficiently accurate and complete explanation. Do not do the student's work for them." }]
                }
            };
            
            let botResponseText = "The Magic was too weak. Professor McGonagall couldn't formulate a response. Try again.";
            let sources = [];

            try {
                if (!API_KEY) {
                     throw new Error("API Key is missing. Please insert your key into the code.");
                }
                
                const response = await withRetry(async () => {
                    const res = await fetch(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorBody = await res.text();
                        throw new Error(`API request failed with status ${res.status}: ${errorBody}`);
                    }
                    return res.json();
                });

                const candidate = response.candidates?.[0];
                const generatedText = candidate?.content?.parts?.[0]?.text;
                
                if (generatedText) {
                    botResponseText = generatedText;
                    
                    // Extract Grounding Sources
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }

            } catch (error) {
                botResponseText = `A critical error occurred: ${error.message}`;
                console.error("Gemini API call failed:", error);
            } finally {
                // 5. Add bot response to history and display
                chatHistory.push({ role: "model", parts: [{ text: botResponseText }], sources: sources });
                displayMessage(botResponseText, 'bot', sources); 
                saveHistory(); // Save updated history
                setLoading(false); // Stop loading 
            }
        };

        // Initialize chat on load
        loadChatHistory();
        
        // Expose function to global scope for HTML inline access
        window.sendMessage = sendMessage;
    </script>
</body>
</html>
