<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat Bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .chat-container {
            max-height: 80vh;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .bot-message {
            background-color: #e0f2fe; /* Light Blue */
            color: #0c4a6e;
        }
        .user-message {
            background-color: #d1fae5; /* Light Green */
            color: #065f46;
        }
        .source-link {
            color: #1d4ed8;
            text-decoration: underline;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: block;
        }
        .source-container {
            border-top: 1px solid #bae6fd;
            padding-top: 0.5rem;
            margin-top: 0.5rem;
        }
        /* Custom scrollbar for aesthetics */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        .message-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin-top: 10px;
        }
    </style>
    <!-- Firebase Imports for Authentication and Persistence -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth;
        let userId = null;
        let isAuthReady = false;

        window.firebaseApp = {
            db: null,
            auth: null,
            appId: appId,
            initialAuthToken: initialAuthToken
        };
        
        const CHAT_COLLECTION = "chat_messages"; 
        
        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            window.firebaseApp.db = db;
            window.firebaseApp.auth = auth;
            // setLogLevel('Debug'); // Uncomment for debugging
        }

        // Handle Authentication
        if (auth) {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                } else if (!user) {
                    // Sign in if not authenticated
                    const signIn = initialAuthToken 
                        ? signInWithCustomToken(auth, initialAuthToken)
                        : signInAnonymously(auth);
                    
                    signIn.then(cred => {
                        userId = cred.user.uid;
                    }).catch(error => console.error("Firebase Sign-in Failed:", error));
                }
                // Once we have a user ID (anonymous or custom token), we can start listening for data
                if (userId) {
                    isAuthReady = true;
                    // Start listening for chat messages
                    document.dispatchEvent(new CustomEvent('authReady')); 
                }
            });
        }
    </script>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">
    <div id="chat-widget" class="w-full max-w-2xl bg-white shadow-xl rounded-2xl p-6 flex flex-col h-[90vh]">
        
        <!-- Header -->
        <header class="pb-4 border-b border-gray-200">
            <h1 class="text-3xl font-bold text-gray-800 flex items-center">
                <svg class="w-7 h-7 mr-2 text-purple-600" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.303L10 17.636l6.619 1.317a1 1 0 001.169-1.303l-7-14z"></path></svg>
                Professor McGonagall's Science Class
            </h1>
            <p class="text-sm text-gray-500 mt-1">Dispelling fallacies with academic rigor. Pay close attention, student.</p>
        </header>

        <!-- Chat Display Area -->
        <div id="messages" class="chat-container flex-grow py-4 space-y-4">
            <!-- Messages will be injected here by the Firestore listener -->
            <div id="auth-loading" class="text-center text-gray-500 italic mt-4">Initializing magic... Please wait for authentication.</div>
        </div>

        <!-- Input Area -->
        <div class="pt-4 border-t border-gray-200">
            <div class="flex space-x-3">
                <input type="text" id="user-input" placeholder="Type your name or query here..."
                       class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                       onkeydown="if(event.key === 'Enter') sendMessage()">
                <button id="send-button" onclick="sendMessage()" disabled
                        class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-xl hover:bg-indigo-700 transition duration-150 flex items-center justify-center disabled:bg-indigo-400">
                    <span id="send-text">Send</span>
                    <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { collection, addDoc, query, orderBy, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const userInput = document.getElementById('user-input');
        const messagesContainer = document.getElementById('messages');
        const sendButton = document.getElementById('send-button');
        const sendText = document.getElementById('send-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const authLoadingDiv = document.getElementById('auth-loading');

        // --- API & Model Configuration ---
        // !!! IMPORTANT: The API_KEY must be inserted here for external hosting. !!!
        const API_KEY = "AIzaSyB0VYddwvfQtAKVeD2zyk7PzVYvALMLiVg"; 
        const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${API_KEY}`;
        
        let chatHistory = [];
        const CHAT_COLLECTION = "chat_messages";
        
        // Wait for Firebase to initialize and authenticate before proceeding
        document.addEventListener('authReady', () => {
            authLoadingDiv.classList.add('hidden');
            sendButton.disabled = false;
            loadChatHistory();
        });


        /**
         * Utility function for exponential backoff retry logic.
         */
        async function withRetry(fn, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Max retries reached. Failing.");
                        throw error;
                    }
                    // Wait for 2^i seconds
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Adds a message bubble to the chat interface. (Used by onSnapshot)
         */
        function displayMessage(text, sender, sources = [], imageUrl = null) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `${sender}-message max-w-xs md:max-w-md p-3 rounded-xl shadow-md whitespace-pre-wrap`;
            
            if (sender === 'user') {
                messageBubble.classList.add('rounded-tr-none');
            } else {
                messageBubble.classList.add('rounded-tl-none');
            }

            let formattedText = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            messageBubble.innerHTML = formattedText;

            // Add image if provided
            if (imageUrl) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = "Illustration for the topic";
                img.className = "message-image";
                
                // If the message is only an image, clear the text content
                if (!text.trim()) {
                    messageBubble.innerHTML = '';
                    // If the imageUrl is a placeholder text, display it below the image
                    if (imageUrl.includes("via.placeholder.com") && imageUrl.includes("?text=")) {
                        const textMatch = imageUrl.match(/\?text=(.*)/);
                        if (textMatch && textMatch[1]) {
                             const altText = decodeURIComponent(textMatch[1]).replace(/\+/g, ' ');
                             const caption = document.createElement('p');
                             caption.className = "text-xs italic text-gray-500 mt-2";
                             caption.textContent = `[Image: ${altText}]`;
                             messageBubble.appendChild(caption);
                        }
                    }
                }

                messageBubble.appendChild(img);
            }
            
            // Add sources if available
            if (sources && sources.length > 0) {
                const sourceContainer = document.createElement('div');
                sourceContainer.className = 'source-container mt-2 pt-2 border-t border-blue-200 text-xs text-gray-600';
                sourceContainer.innerHTML = '<strong>Sources:</strong>';
                
                const uniqueSources = new Map();
                sources.forEach(source => {
                    if (source.uri && source.title) {
                        uniqueSources.set(source.uri, source.title);
                    }
                });

                uniqueSources.forEach((title, uri) => {
                    const link = document.createElement('a');
                    link.className = 'source-link block truncate hover:text-blue-700';
                    link.href = uri;
                    link.target = '_blank';
                    link.textContent = title;
                    sourceContainer.appendChild(link);
                });
                
                messageBubble.appendChild(sourceContainer);
            }

            messageWrapper.appendChild(messageBubble);
            messagesContainer.appendChild(messageWrapper);

            // Scroll to the latest message
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        /**
         * Toggles the loading state for the button and input field.
         */
        function setLoading(isLoading) {
            // Note: We don't disable the button completely here anymore, 
            // as we want to allow text messages while an image is generating.
            if (isLoading) {
                sendText.classList.add('hidden');
                loadingSpinner.classList.remove('hidden');
            } else {
                sendText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
            }
        }

        /**
         * Saves a message (user or bot) to Firestore.
         */
        async function saveMessage(sender, text, sources = null, imageUrl = null) {
            const { db, appId } = window.firebaseApp;
            const userId = window.firebaseApp.auth?.currentUser?.uid;

            if (!db || !userId) {
                console.error("Firestore or user not ready. Cannot save message.");
                return;
            }
            const path = `artifacts/${appId}/users/${userId}/${CHAT_COLLECTION}`;
            try {
                await addDoc(collection(db, path), {
                    sender: sender,
                    text: text,
                    sources: sources,
                    imageUrl: imageUrl,
                    timestamp: serverTimestamp() 
                });
            } catch (e) {
                console.error("Error adding document to Firestore: ", e);
            }
        }

        /**
         * Generates an image using the Imagen API and returns a data URL.
         */
        async function generateImage(prompt) {
            const imagePayload = { 
                instances: [{ prompt: prompt }], 
                parameters: { "sampleCount": 1 } 
            };

            try {
                const response = await withRetry(async () => {
                    const res = await fetch(IMAGE_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(imagePayload)
                    });

                    if (!res.ok) {
                        const errorBody = await res.text();
                        throw new Error(`Image API request failed with status ${res.status}: ${errorBody}`);
                    }
                    return res.json();
                });

                const base64Data = response?.predictions?.[0]?.bytesBase64Encoded;
                
                if (base64Data) {
                    return `data:image/png;base64,${base64Data}`;
                }

                console.error("Image generation failed: No base64 data received.");
                // Return a cute, non-obtrusive fallback placeholder
                return `https://via.placeholder.com/200/F4C2C2/FFFFFF?text=Magic+Glitch`;

            } catch (error) {
                console.error("Image generation API call failed:", error);
                // Return a cute, non-obtrusive fallback placeholder
                return `https://via.placeholder.com/200/F4C2C2/FFFFFF?text=Magic+Glitch`;
            }
        }

        /**
         * Sets up a real-time listener for the chat history.
         */
        function loadChatHistory() {
            const { db, appId } = window.firebaseApp;
            const userId = window.firebaseApp.auth?.currentUser?.uid;

            if (!db || !userId) return;
            
            const path = `artifacts/${appId}/users/${userId}/${CHAT_COLLECTION}`;
            // Use orderBy to ensure messages are loaded in chronological order
            const q = query(collection(db, path), orderBy('timestamp', 'asc')); 

            onSnapshot(q, (snapshot) => {
                // Clear current messages and chatHistory to rebuild the entire state
                messagesContainer.innerHTML = '';
                chatHistory = []; 
                let initialBotMessageFound = false;

                snapshot.forEach((doc) => {
                    const data = doc.data();
                    
                    // Rebuild the UI using the data from Firestore
                    displayMessage(data.text || '', data.sender, data.sources, data.imageUrl);
                    
                    // Rebuild the Gemini Chat History for API context (only use text, ignore images for chat context)
                    if (data.text) {
                        if (data.sender === 'bot') {
                            chatHistory.push({ role: "model", parts: [{ text: data.text }] });
                        } else if (data.sender === 'user') {
                            chatHistory.push({ role: "user", parts: [{ text: data.text }] });
                        }
                    }
                    
                    if (data.text && data.text.includes("Welcome, student. Before we commence our rigorous lesson")) {
                        initialBotMessageFound = true;
                    }
                });
                
                // If this is the first time loading the chat, add the initial bot message to Firestore
                if (snapshot.empty || !initialBotMessageFound) {
                     const welcomeText = "Welcome, student. Before we commence our rigorous lesson on scientific misconceptions, please state your name.";
                     // Using a fixed welcome placeholder to avoid running the expensive generator on initial load
                     saveMessage('bot', welcomeText, [], 'https://via.placeholder.com/200/90EE90/FFFFFF?text=Cute+Welcome+Owl');
                }

            }, (error) => {
                console.error("Firestore snapshot error:", error);
                displayMessage("A disturbance in the magic prevented us from loading your previous lessons.", 'bot');
            });
        }


        /**
         * Handles sending the user message to the Gemini API.
         */
        window.sendMessage = async function() {
            const query = userInput.value.trim();
            if (!query || !window.firebaseApp.auth?.currentUser?.uid) return;

            // 1. Save user message to Firestore (onSnapshot will handle displaying it)
            await saveMessage('user', query);
            
            // 2. Clear input and start loading
            userInput.value = '';
            setLoading(true);
            
            // 3. Construct API Payload
            const payload = {
                contents: chatHistory, // Use history rebuilt by the listener
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: "You are Professor Minerva McGonagal, a stern but fair professor from Hogwarts, with a special interest in teaching students the correct understanding of science. Your task is to act as a rigorous tutor on scientific misconceptions.\n\n**Protocol:**\n1. If the student has not provided a name, immediately ask them for their name.\n2. Once the name is provided, select a common scientific misconception (e.g., 'cracking knuckles causes arthritis', 'sugar makes kids hyperactive', 'seasons are caused by Earth's distance from the sun', etc.) and ask the student to explain why it is a misconception and what the correct scientific understanding is.\n3. Use formal, professorial language, like a professor from Hogwarts.\n4. Do NOT provide the correct explanation yourself. Your purpose is to guide. Instead, guide the student with follow-up questions to help them reach the correct answer.\n5. Only proceed to a new topic or end the lesson once the student has provided a sufficiently accurate and complete explanation of the misconception. Do not do the student's work for them.\n6. **Always include a cute, relevant image prompt at the end of your response text, separated by a newline, in the exact format: 'Cute image: [Your prompt here].' to trigger the image generation logic below.**" }]
                }
            };
            
            let finalImagePrompt = null;

            try {
                const response = await withRetry(async () => {
                    const res = await fetch(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorBody = await res.text();
                        throw new Error(`API request failed with status ${res.status}: ${errorBody}`);
                    }
                    return res.json();
                });

                const candidate = response.candidates?.[0];
                let botResponseText = candidate?.content?.parts?.[0]?.text;
                
                if (botResponseText) {
                    
                    // 4. Extract Grounding Sources
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    // 5. Extract Image Prompt and clean up text
                    const imagePromptMatch = botResponseText.match(/Cute image:\s*(.*)/i);
                    if (imagePromptMatch) {
                        finalImagePrompt = imagePromptMatch[1].trim();
                        // Remove the image prompt line from the text response
                        botResponseText = botResponseText.replace(imagePromptMatch[0], '').trim();
                    }

                    // 6. Save bot text response to Firestore (no image URL in this document)
                    await saveMessage('bot', botResponseText, sources, null); 

                    // 7. If an image prompt was found, generate the image and save it as a separate document
                    if (finalImagePrompt) {
                        // The spinner is already active from step 2, indicating ongoing work
                        const imageUrl = await generateImage(finalImagePrompt);
                        
                        if (imageUrl) {
                            // Save the generated image as a separate message (no text, just image URL)
                            // The text field saves the prompt for reference
                            await saveMessage('bot', `Image generated from prompt: "${finalImagePrompt}"`, null, imageUrl);
                        }
                    }

                } else {
                    await saveMessage('bot', "The Magic was too weak. Professor McGonagall couldn't formulate a response. Try again.", []);
                }

            } catch (error) {
                // This block is crucial for fixing the infinite spinner in CORS scenarios
                const errorMessage = "A critical network error occurred. Please check the browser console for CORS errors. Professor McGonagall is currently unable to receive owl post. (Hint: Ensure you have inserted a valid API key and are running the file from a web server.)";
                await saveMessage('bot', errorMessage, []);
                console.error("Gemini API call failed:", error);
            } finally {
                setLoading(false); // Stop loading after all steps are complete
            }
        };

        // Expose function to global scope for HTML inline access
        window.sendMessage = sendMessage;
    </script>
</body>
</html>
