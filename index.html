<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI Chatbot</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font family -->
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f7fafc; }
        .chat-area { max-height: calc(100vh - 12rem); overflow-y: auto; }
        .user-message { background-color: #3b82f6; color: white; border-radius: 12px 12px 0 12px; }
        .model-message { background-color: #e5e7eb; color: #1f2937; border-radius: 12px 12px 12px 0; }
        /* Custom scrollbar for chat-area */
        .chat-area::-webkit-scrollbar { width: 8px; }
        .chat-area::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        .chat-area::-webkit-scrollbar-track { background: #f1f1f1; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 bg-gray-100">

    <div class="w-full max-w-2xl bg-white shadow-xl rounded-xl flex flex-col h-[90vh]">
        <!-- Header -->
        <header class="p-4 bg-indigo-600 text-white rounded-t-xl shadow-md">
            <h1 class="text-2xl font-bold">
                <span class="inline-block align-middle">ðŸ”¬ Professor McGonagall's Science Class</span>
            </h1>
            <p id="user-id-display" class="text-xs mt-1 opacity-75 truncate">Initializing...</p>
        </header>

        <!-- Chat Messages Area -->
        <main id="chat-area" class="chat-area flex-grow p-4 space-y-4">
            <!-- Messages will be injected here -->
            <div id="loading-initial" class="flex justify-center items-center h-full text-gray-500">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Loading chat history...
            </div>
        </main>

        <!-- Input Area -->
        <footer class="p-4 border-t border-gray-200 bg-white rounded-b-xl">
            <form id="chat-form" class="flex gap-2">
                <input type="text" id="user-input" placeholder="Say 'Hello' to enter the classroom..."
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                       autocomplete="off">
                <button type="submit" id="send-button"
                        class="bg-indigo-600 text-white p-3 rounded-lg hover:bg-indigo-700 transition duration-150 disabled:bg-indigo-400"
                        title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </form>
            <p id="error-message" class="text-sm text-red-500 mt-2 hidden"></p>
        </footer>
    </div>

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, setLogLevel, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Configuration
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent`;
        const API_KEY = ""; // Canvas environment will provide the key if empty

        // UI elements
        const chatArea = document.getElementById('chat-area');
        const chatForm = document.getElementById('chat-form');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const errorDisplay = document.getElementById('error-message');
        const userIdDisplay = document.getElementById('user-id-display');
        const loadingInitial = document.getElementById('loading-initial');

        // State
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        let conversationHistory = []; // Stores the history in Firestore format for UI display
        let isAITyping = false;
        
        // --- UTILITY FUNCTIONS ---

        /**
         * Implements exponential backoff for retrying failed API calls.
         * @param {function} callback - The function that performs the fetch request.
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function fetchWithRetry(callback, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await callback();
                    if (response.status === 429) {
                         // Too Many Requests, retry
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        console.warn(`Rate limit hit (429). Retrying in ${Math.round(delay/1000)}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API Error: ${response.status} - ${errorBody}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error; // Throw the error if max retries reached
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    console.error(`Attempt ${i + 1} failed. Retrying in ${Math.round(delay/1000)}s. Error: ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // --- FIREBASE / AUTHENTICATION ---

        /**
         * Initializes Firebase and authenticates the user.
         */
        function initializeFirebase() {
            try {
                // setLogLevel('debug'); // Uncomment for debugging Firestore/Auth issues
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for authentication state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        userIdDisplay.textContent = `User ID: ${userId}`;
                        setupRealtimeChatListener();
                    } else {
                        // Attempt to sign in if not already authenticated
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Fallback to anonymous sign-in if no custom token is provided
                            await signInAnonymously(auth);
                        }
                    }
                });

                // Force sign-in attempt if not started by onAuthStateChanged
                if (!auth.currentUser) {
                    if (initialAuthToken) {
                        signInWithCustomToken(auth, initialAuthToken).catch(e => console.error("Custom Auth failed:", e));
                    } else {
                        signInAnonymously(auth).catch(e => console.error("Anonymous Auth failed:", e));
                    }
                }

            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                loadingInitial.innerHTML = `<p class="text-red-500">Error initializing application. See console for details.</p>`;
            }
        }


        // --- FIRESTORE CHAT MANAGEMENT ---

        /**
         * Sets up the real-time listener for the chat history.
         */
        function setupRealtimeChatListener() {
            if (!isAuthReady || !userId) return;

            // Path for private user messages: /artifacts/{appId}/users/{userId}/messages
            const chatCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/messages`);
            
            // Query ordered by timestamp
            const q = query(chatCollectionRef, orderBy('timestamp', 'asc'));

            onSnapshot(q, (snapshot) => {
                const updatedHistory = [];
                snapshot.forEach((doc) => {
                    updatedHistory.push({ id: doc.id, ...doc.data() });
                });
                conversationHistory = updatedHistory;
                renderChat(conversationHistory);
                loadingInitial.classList.add('hidden');
            }, (error) => {
                console.error("Firestore real-time error:", error);
                loadingInitial.innerHTML = `<p class="text-red-500">Error loading chat history. See console for details.</p>`;
            });
        }

        /**
         * Adds a new message to Firestore.
         * @param {string} role - 'user' or 'model'.
         * @param {string} text - The message content.
         */
        async function addMessageToFirestore(role, text) {
            if (!db || !userId) {
                console.error("Database or User ID not available.");
                return;
            }

            const chatCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/messages`);
            
            try {
                await addDoc(chatCollectionRef, {
                    role: role,
                    text: text,
                    timestamp: serverTimestamp() // Use server timestamp for accurate ordering
                });
            } catch (e) {
                console.error("Error adding document: ", e);
                showError("Failed to save message to history.");
            }
        }

        // --- UI RENDERING ---

        /**
         * Renders the entire chat history to the UI.
         * @param {Array<Object>} history - The conversation history array.
         */
        function renderChat(history) {
            chatArea.innerHTML = ''; // Clear existing messages
            
            history.forEach(message => {
                const messageElement = createMessageElement(message.role, message.text);
                chatArea.appendChild(messageElement);
            });

            // Dynamic Placeholder Logic
            updatePlaceholder(history);

            // Add the temporary typing indicator if needed
            if (isAITyping) {
                 const typingIndicator = createTypingIndicator();
                 chatArea.appendChild(typingIndicator);
            }

            // Scroll to the bottom
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        /**
         * Updates the input placeholder based on the context of the last message.
         * @param {Array<Object>} history - The conversation history array.
         */
        function updatePlaceholder(history) {
            if (history.length === 0) {
                userInput.placeholder = "Say 'Hello' to start class...";
                return;
            }

            const lastMessage = history[history.length - 1];
            if (lastMessage.role === 'model') {
                const text = lastMessage.text.toLowerCase();
                
                if (text.includes("name") && text.includes("ready")) {
                    userInput.placeholder = "State your name clearly, please...";
                } else if (text.includes("misconception") || text.includes("explain")) {
                    userInput.placeholder = "Explain yourself clearly...";
                } else if (text.includes("?")) {
                    userInput.placeholder = "Answer the question, if you please...";
                } else {
                    userInput.placeholder = "Type your response here...";
                }
            }
        }

        /**
         * Creates a single chat message element.
         * @param {string} role - 'user' or 'model'.
         * @param {string} text - The message content.
         * @returns {HTMLElement} The created div element.
         */
        function createMessageElement(role, text) {
            const isUser = role === 'user';
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-[80%] p-3 shadow-md ${isUser ? 'user-message' : 'model-message'}`;
            messageBubble.innerHTML = formatText(text); // Use innerHTML for Markdown

            messageWrapper.appendChild(messageBubble);
            return messageWrapper;
        }

        /**
         * Creates a simple typing indicator.
         */
        function createTypingIndicator() {
            const messageWrapper = document.createElement('div');
            messageWrapper.id = 'typing-indicator';
            messageWrapper.className = 'flex justify-start';

            const messageBubble = document.createElement('div');
            messageBubble.className = 'max-w-[80%] p-3 shadow-md model-message';
            
            // Simple pulsating dots
            messageBubble.innerHTML = `
                <span class="inline-block h-2 w-2 bg-gray-600 rounded-full animate-pulse mx-0.5"></span>
                <span class="inline-block h-2 w-2 bg-gray-600 rounded-full animate-pulse mx-0.5" style="animation-delay: 0.2s;"></span>
                <span class="inline-block h-2 w-2 bg-gray-600 rounded-full animate-pulse mx-0.5" style="animation-delay: 0.4s;"></span>
            `;

            messageWrapper.appendChild(messageBubble);
            return messageWrapper;
        }

        /**
         * Basic text formatting (handles newlines).
         */
        function formatText(text) {
            // Replace newlines with <br> for simple multi-line display
            return text.replace(/\n/g, '<br>');
        }

        /**
         * Displays a temporary error message in the footer.
         * @param {string} message - The error message.
         */
        function showError(message) {
            errorDisplay.textContent = `Error: ${message}`;
            errorDisplay.classList.remove('hidden');
            setTimeout(() => errorDisplay.classList.add('hidden'), 5000);
        }

        // --- GEMINI API INTEGRATION ---

        /**
         * Calls the Gemini API to get a response.
         * @param {Array<Object>} history - The conversation history.
         * @param {string} userMessage - The latest user message.
         */
        async function getGeminiResponse(history, userMessage) {
            // Map the Firestore history structure to the Gemini API contents structure
            const contents = history.map(msg => ({
                role: msg.role,
                parts: [{ text: msg.text }]
            }));
            
            // Add the current user message to the contents array
            contents.push({ role: 'user', parts: [{ text: userMessage }] });

            const payload = {
                contents: contents,
                // Optional: Add system instructions to define the bot's persona
                systemInstruction: {
                    parts: [{ text: "You are Professor Minerva McGonagall, Deputy Headmistress of Hogwarts School of Witchcraft and Wizardry and head of Gryffindor House. You are stern, precise, authoritative, but fair. You do not tolerate foolishness, but you deeply care about your students' education. Adopt her distinct manner of speaking: crisp, formal, and occasionally using magical metaphors (e.g., 'Five points to Gryffindor' for a good answer, or 'Do not be woolly-headed'). Your goal is to act as a Biology Professor specializing in debunking common scientific misconceptions. Your first and ONLY response to the student MUST be a crisp greeting, asking for their name, and demanding confirmation that they are ready to begin the Misconception Cycle. Do NOT start the cycle with the misconception challenges yet. Once the student has provided their name and confirmed they are ready, you MUST immediately begin the structured cycle. The cycle is now focused on one topic at a time. 1. You will select ONE common scientific misconception (from biology, physics, or general science) and ask the student to explain that specific misconception (e.g., 'Explain why we have seasons'). 2. If the student's explanation is incorrect or incomplete, you MUST NOT provide the correct answer. Instead, ask a follow-up, probing question designed to guide the student toward self-correction. Continue this probing dialogue until the student has demonstrated a strong understanding of the concept. 3. Once the student has demonstrated correct understanding, only then congratulate them (perhaps with house points), provide a concise summary of the correct concept, and immediately start a new cycle (Steps 1 & 2 repeated) by selecting ONE NEW misconception and asking the student to explain it." }]
                },
                config: {
                    // Optional: You can enable Google Search grounding here if needed for real-time information
                    tools: [{ "google_search": {} }]
                }
            };

            const apiUrl = `${API_BASE_URL}?key=${API_KEY}`;

            try {
                const response = await fetchWithRetry(() => 
                    fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    })
                );

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    return text;
                } else {
                    const errorMsg = result.error?.message || "Model returned an empty or invalid response.";
                    throw new Error(errorMsg);
                }
            } catch (e) {
                console.error("Gemini API call failed:", e);
                showError("AI service failed to respond. Please try again.");
                return null;
            }
        }

        // --- EVENT HANDLERS ---

        /**
         * Handles the form submission.
         * @param {Event} e - The form submit event.
         */
        async function handleChatSubmit(e) {
            e.preventDefault();

            if (!isAuthReady) {
                showError("Authentication is still loading. Please wait a moment.");
                return;
            }

            const userMessage = userInput.value.trim();
            if (!userMessage || isAITyping) return;

            // 1. Disable input and set typing state
            userInput.value = '';
            userInput.placeholder = "Professor McGonagall is evaluating..."; // Immediate feedback
            userInput.disabled = true;
            sendButton.disabled = true;
            isAITyping = true;
            renderChat(conversationHistory); // Renders the typing indicator

            // 2. Save user message to Firestore (which triggers UI update via onSnapshot)
            await addMessageToFirestore('user', userMessage);

            // 3. Get AI response
            const aiResponseText = await getGeminiResponse(conversationHistory, userMessage);
            
            // 4. Save AI response to Firestore
            if (aiResponseText) {
                await addMessageToFirestore('model', aiResponseText);
            } else {
                 // Save a fallback error message if the AI failed
                 await addMessageToFirestore('model', "I'm sorry, I was unable to process your request. Please check the console for API errors.");
            }

            // 5. Reset state
            isAITyping = false;
            
            // Remove the temporary typing indicator and re-render the chat
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }

            userInput.disabled = false;
            sendButton.disabled = false;
            userInput.focus();
            
            // Scroll to the bottom one last time to ensure the final message is visible
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // --- INITIALIZATION ---
        chatForm.addEventListener('submit', handleChatSubmit);
        initializeFirebase();

    </script>
</body>
</html>
